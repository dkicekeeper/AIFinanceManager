//
//  IncomeExpenseChart.swift
//  AIFinanceManager
//
//  Phase 17/18: Financial Insights Feature
//  Grouped bar chart showing income vs expenses.
//  Phase 18 additions:
//  - PeriodDataPoint overload (granularity-aware)
//  - Horizontal scroll when point count exceeds screen width
//
//  Phase 23-C: Replaced UIScreen.main.bounds with GeometryReader — no UIKit dependency.
//
//  Phase 27:
//  - Compact mode: glow shadow removed from bars
//  - All bars: AppRadius.sm corner radius (not pill)
//  - Full mode: Y-axis moved to leading overlay (always visible while scrolling)
//  - Default horizontal scroll position: trailing (most recent data)
//  - Bar width: .automatic for full mode (prevents overlap)
//
//  Phase 28:
//  - Removed local formatCompact / formatAxisDate / axisMonthFormatter → ChartAxisHelpers
//  - Removed local axisLabelMap / compactPeriodLabel → ChartAxisHelpers
//  - IncomeExpenseChart: scrollable branch refactored to ZStack Y-axis overlay
//  - PeriodIncomeExpenseChart: chartHeight 220 → 200 (visual parity with other charts)
//

import SwiftUI
import Charts

// MARK: - IncomeExpenseChart (MonthlyDataPoint — legacy)

struct IncomeExpenseChart: View {
    let dataPoints: [MonthlyDataPoint]
    let currency: String
    var mode: ChartDisplayMode = .full
    private var isCompact: Bool { mode == .compact }
    /// When true, wraps in a horizontal ScrollView (Phase 18)
    var scrollable: Bool = false

    // MARK: Body

    var body: some View {
        if scrollable && !isCompact && dataPoints.count > 6 {
            let pointWidth: CGFloat = 50
            GeometryReader { proxy in
                let container = proxy.size.width
                let yAxisWidth: CGFloat = 50
                let scrollWidth = max(container, CGFloat(dataPoints.count) * pointWidth)
                ZStack(alignment: .topLeading) {
                    ScrollView(.horizontal, showsIndicators: false) {
                        chartContent(showYAxis: false)
                            .frame(width: scrollWidth, height: 200)
                    }
                    .scrollBounceBehavior(.basedOnSize)
                    .defaultScrollAnchor(.trailing)

                    // Y-axis overlay — always visible, doesn't scroll with chart
                    yAxisReferenceChart
                        .frame(width: yAxisWidth, height: 200)
                        .allowsHitTesting(false)
                }
            }
            .frame(height: 200)
            .padding(.top, AppSpacing.sm)
        } else {
            chartContent(showYAxis: !isCompact)
        }
    }

    // MARK: - Y-axis reference chart (overlay for scrollable mode)

    private var yAxisReferenceChart: some View {
        Chart(dataPoints) { point in
            BarMark(x: .value("Month", point.month), y: .value("Amount", point.income))
                .opacity(0)
            BarMark(x: .value("Month", point.month), y: .value("Amount", point.expenses))
                .opacity(0)
        }
        .chartXAxis { AxisMarks { _ in } }
        .chartYAxis {
            AxisMarks(position: .leading) { value in
                AxisValueLabel {
                    if let amount = value.as(Double.self) {
                        Text(ChartAxisHelpers.formatCompact(amount))
                            .font(AppTypography.caption2)
                    }
                }
            }
        }
    }

    // MARK: - Chart content

    private func chartContent(showYAxis: Bool) -> some View {
        Chart(dataPoints) { point in
            BarMark(
                x: .value("Month", point.month),
                y: .value("Amount", point.income),
                width: isCompact ? 6 : 12
            )
            .cornerRadius(AppRadius.xs)
            .foregroundStyle(AppColors.success.opacity(0.85))
            .position(by: .value("Type", "Income"))

            BarMark(
                x: .value("Month", point.month),
                y: .value("Amount", point.expenses),
                width: isCompact ? 6 : 12
            )
            .cornerRadius(AppRadius.xs)
            .foregroundStyle(AppColors.destructive.opacity(0.85))
            .position(by: .value("Type", "Expenses"))
        }
        .chartXAxis {
            if isCompact {
                AxisMarks { _ in }
            } else {
                AxisMarks(values: .stride(by: .month)) { value in
                    AxisValueLabel {
                        if let date = value.as(Date.self) {
                            Text(ChartAxisHelpers.formatAxisDate(date))
                                .font(AppTypography.caption2)
                        }
                    }
                }
            }
        }
        .chartYAxis {
            if isCompact {
                AxisMarks { _ in }
            } else if showYAxis {
                AxisMarks(position: .leading) { value in
                    AxisGridLine()
                    AxisValueLabel {
                        if let amount = value.as(Double.self) {
                            Text(ChartAxisHelpers.formatCompact(amount))
                                .font(AppTypography.caption2)
                        }
                    }
                }
            } else {
                // Grid lines only — Y labels handled by yAxisReferenceChart overlay
                AxisMarks { _ in
                    AxisGridLine()
                    AxisValueLabel { EmptyView() }
                }
            }
        }
        .chartForegroundStyleScale([
            "Income": AppColors.success,
            "Expenses": AppColors.destructive
        ])
        .chartLegend(isCompact ? .hidden : .automatic)
        .frame(height: isCompact ? 60 : 200)
    }
}

// MARK: - PeriodIncomeExpenseChart (PeriodDataPoint — Phase 18)

/// Granularity-aware income/expense bar chart.
/// X-axis shows period labels (week/month/quarter/year) instead of raw Date.
/// Y-axis is pinned to the left (always visible) while content scrolls right.
/// Default scroll position: trailing (most recent data visible on load).
struct PeriodIncomeExpenseChart: View {
    let dataPoints: [PeriodDataPoint]
    let currency: String
    let granularity: InsightGranularity
    var mode: ChartDisplayMode = .full
    private var isCompact: Bool { mode == .compact }

    private var pointWidth: CGFloat { isCompact ? 30 : granularity.pointWidth }
    private var chartHeight: CGFloat { isCompact ? 60 : 200 }

    /// Maximum Y value across all data points — used to sync Y-axis scale.
    private var yMax: Double {
        dataPoints.flatMap { [$0.income, $0.expenses] }.max() ?? 1
    }

    // MARK: Body

    var body: some View {
        GeometryReader { proxy in
            let container = proxy.size.width
            let yAxisWidth: CGFloat = 50

            if isCompact {
                // Compact: single chart, no Y-axis, no scroll
                mainChart(showYAxis: false)
                    .frame(width: container, height: chartHeight)
            } else {
                let scrollWidth = max(
                    container,
                    CGFloat(dataPoints.count) * pointWidth
                )
                ZStack(alignment: .topLeading) {
                    // Scrollable bars (Y-axis hidden)
                    ScrollView(.horizontal, showsIndicators: false) {
                        mainChart(showYAxis: false)
                            .frame(width: scrollWidth, height: chartHeight)
                    }
                    .scrollBounceBehavior(.basedOnSize)
                    .defaultScrollAnchor(.trailing)

                    // Y-axis overlay — always visible, doesn't scroll with chart
                    yAxisReferenceChart
                        .frame(width: yAxisWidth, height: chartHeight)
                        .allowsHitTesting(false)
                }
            }
        }
        .frame(height: chartHeight)
        .padding(.top, isCompact ? 0 : AppSpacing.sm)
    }

    // MARK: - Y-axis reference chart (left panel, always visible)

    /// Invisible chart used solely to render the Y-axis labels with correct scale.
    private var yAxisReferenceChart: some View {
        Chart(dataPoints) { point in
            BarMark(x: .value("p", point.label), y: .value("v", point.income))
                .opacity(0)
            BarMark(x: .value("p", point.label), y: .value("v", point.expenses))
                .opacity(0)
        }
        .chartYScale(domain: 0...yMax)
        .chartXAxis { AxisMarks { _ in } }
        .chartYAxis {
            AxisMarks(position: .leading) { value in
                AxisValueLabel {
                    if let amount = value.as(Double.self) {
                        Text(ChartAxisHelpers.formatCompact(amount))
                            .font(AppTypography.caption2)
                    }
                }
            }
        }
    }

    // MARK: - Main chart (bars + X-axis, optionally no Y-axis)

    private func mainChart(showYAxis: Bool) -> some View {
        Chart(dataPoints) { point in
            BarMark(
                x: .value("Period", point.label),
                y: .value("Income", point.income),
                width: isCompact ? .fixed(6) : .automatic
            )
            .cornerRadius(AppRadius.sm)
            .foregroundStyle(AppColors.success.opacity(0.85))
            .shadow(
                color: isCompact ? .clear : AppColors.success.opacity(0.35),
                radius: isCompact ? 0 : 4, x: 0, y: 2
            )
            .position(by: .value("Type", "Income"))

            BarMark(
                x: .value("Period", point.label),
                y: .value("Expenses", point.expenses),
                width: isCompact ? .fixed(6) : .automatic
            )
            .cornerRadius(AppRadius.sm)
            .foregroundStyle(AppColors.destructive.opacity(0.85))
            .shadow(
                color: isCompact ? .clear : AppColors.destructive.opacity(0.35),
                radius: isCompact ? 0 : 4, x: 0, y: 2
            )
            .position(by: .value("Type", "Expenses"))
        }
        .chartYScale(domain: 0...yMax)
        .chartXAxis {
            if isCompact {
                AxisMarks { _ in }
            } else {
                let labelMap = ChartAxisHelpers.axisLabelMap(for: dataPoints)
                AxisMarks { value in
                    AxisValueLabel {
                        if let label = value.as(String.self) {
                            Text(labelMap[label] ?? label)
                                .font(AppTypography.caption2)
                                .lineLimit(1)
                        }
                    }
                }
            }
        }
        .chartYAxis {
            if showYAxis {
                AxisMarks(position: .leading) { value in
                    AxisGridLine()
                    AxisValueLabel {
                        if let amount = value.as(Double.self) {
                            Text(ChartAxisHelpers.formatCompact(amount))
                                .font(AppTypography.caption2)
                        }
                    }
                }
            } else {
                // Grid lines only — Y labels handled by yAxisReferenceChart
                AxisMarks { _ in
                    AxisGridLine()
                    AxisValueLabel { EmptyView() }
                }
            }
        }
        .chartForegroundStyleScale([
            "Income": AppColors.success,
            "Expenses": AppColors.destructive
        ])
        .chartLegend(isCompact ? .hidden : .automatic)
    }
}

// MARK: - Previews

#Preview("Full income/expense chart (legacy)") {
    IncomeExpenseChart(
        dataPoints: MonthlyDataPoint.mockTrend(),
        currency: "KZT"
    )
    .screenPadding()
    .padding(.vertical, AppSpacing.md)
}

#Preview("Compact (summary header)") {
    IncomeExpenseChart(
        dataPoints: MonthlyDataPoint.mockTrend(),
        currency: "KZT",
        mode: .compact
    )
    .screenPadding()
    .frame(height: 80)
}

#Preview("PeriodIncomeExpenseChart — Monthly") {
    PeriodIncomeExpenseChart(
        dataPoints: PeriodDataPoint.mockMonthly(),
        currency: "KZT",
        granularity: .month
    )
    .screenPadding()
    .padding(.vertical, AppSpacing.md)
}
