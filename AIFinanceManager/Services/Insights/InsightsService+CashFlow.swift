//
//  InsightsService+CashFlow.swift
//  AIFinanceManager
//
//  Phase 38: Extracted from InsightsService monolith (2832 LOC â†’ domain files).
//  Responsible for: net cash flow trend, best/worst period, projected balance from recurring.
//

import Foundation
import os

extension InsightsService {

    // MARK: - Cash Flow Insights (legacy timeFilter path)

    @MainActor
    func generateCashFlowInsights(
        allTransactions: [Transaction],
        timeFilter: TimeFilter,
        baseCurrency: String,
        cacheManager: TransactionCacheManager,
        currencyService: TransactionCurrencyService,
        balanceFor: (String) -> Double
    ) -> [Insight] {
        // Choose number of months based on the selected filter preset:
        // "Last Year" / "All Time" â†’ 12 months; anything shorter â†’ 6 months.
        let trendMonths: Int
        switch timeFilter.preset {
        case .lastYear, .allTime:
            trendMonths = 12
        default:
            trendMonths = 6
        }

        Self.logger.debug("ðŸ’¸ [Insights] CashFlow START â€” computing \(trendMonths)-month trend")

        // Bug 1 fix: use the filter's INCLUSIVE end as anchor so historical filters produce
        // month points within their period. timeFilter.dateRange().end is EXCLUSIVE.
        let filterEndExclusive = timeFilter.dateRange().end
        let calendar = Calendar.current
        let anchorDate: Date
        if Calendar.current.isDateInToday(filterEndExclusive) || filterEndExclusive > Date() {
            anchorDate = Date()
        } else {
            anchorDate = calendar.date(byAdding: .second, value: -1, to: filterEndExclusive) ?? filterEndExclusive
        }
        guard let windowStart = calendar.date(byAdding: .month, value: -trendMonths, to: startOfMonth(calendar, for: anchorDate)) else {
            Self.logger.debug("ðŸ’¸ [Insights] CashFlow â€” SKIPPED (could not compute \(trendMonths)-month window)")
            return []
        }
        let windowTransactions = filterService.filterByTimeRange(allTransactions, start: windowStart, end: filterEndExclusive)
        Self.logger.debug("ðŸ’¸ [Insights] CashFlow â€” \(trendMonths)-month window \(Self.monthYearFormatter.string(from: windowStart), privacy: .public) â†’ \(Self.monthYearFormatter.string(from: anchorDate), privacy: .public) (anchor), transactions=\(windowTransactions.count) (was \(allTransactions.count))")

        let monthlyData = computeMonthlyDataPoints(
            transactions: windowTransactions,
            months: trendMonths,
            baseCurrency: baseCurrency,
            cacheManager: cacheManager,
            currencyService: currencyService,
            anchorDate: anchorDate
        )
        guard monthlyData.count >= 2 else {
            Self.logger.debug("ðŸ’¸ [Insights] CashFlow â€” SKIPPED (only \(monthlyData.count) month(s) of data, need â‰¥2)")
            return []
        }

        var insights: [Insight] = []

        // 1. Net cash flow trend
        if let latest = monthlyData.last {
            let avgNetFlow = monthlyData.reduce(0.0) { $0 + $1.netFlow } / Double(monthlyData.count)
            let severity: InsightSeverity = latest.netFlow > 0 ? .positive : (latest.netFlow < 0 ? .critical : .neutral)
            Self.logger.debug("ðŸ’¸ [Insights] Net cash flow â€” latest=\(String(format: "%.0f", latest.netFlow), privacy: .public), avg=\(String(format: "%.0f", avgNetFlow), privacy: .public), severity=\(String(describing: severity), privacy: .public)")

            insights.append(Insight(
                id: "net_cashflow",
                type: .netCashFlow,
                title: String(localized: "insights.netCashFlow"),
                subtitle: latest.label,
                metric: InsightMetric(
                    value: latest.netFlow,
                    formattedValue: Formatting.formatCurrencySmart(latest.netFlow, currency: baseCurrency),
                    currency: baseCurrency,
                    unit: nil
                ),
                trend: InsightTrend(
                    direction: latest.netFlow > avgNetFlow ? .up : (latest.netFlow < avgNetFlow ? .down : .flat),
                    changePercent: nil,
                    changeAbsolute: latest.netFlow - avgNetFlow,
                    comparisonPeriod: String(localized: "insights.vsAverage")
                ),
                severity: severity,
                category: .cashFlow,
                detailData: .monthlyTrend(monthlyData)
            ))
        }

        // 2. Best month
        if let best = monthlyData.max(by: { $0.netFlow < $1.netFlow }) {
            insights.append(Insight(
                id: "best_month",
                type: .bestMonth,
                title: String(localized: "insights.bestMonth"),
                subtitle: best.label,
                metric: InsightMetric(
                    value: best.netFlow,
                    formattedValue: Formatting.formatCurrencySmart(best.netFlow, currency: baseCurrency),
                    currency: baseCurrency,
                    unit: nil
                ),
                trend: nil,
                severity: .positive,
                category: .cashFlow,
                detailData: .monthlyTrend(monthlyData)
            ))
        }

        // 3. Projected balance (30 days ahead) â€” show recurring impact delta
        let currentBalance = transactionStore.accounts.reduce(0.0) { $0 + balanceFor($1.id) }
        let recurringNet = monthlyRecurringNet(baseCurrency: baseCurrency)
        let projectedBalance = currentBalance + recurringNet

        let accountCount = transactionStore.accounts.count
        Self.logger.debug("ðŸ’¸ [Insights] Projected balance â€” accounts=\(accountCount), currentBalance=\(String(format: "%.0f", currentBalance), privacy: .public), recurringNet=\(String(format: "%+.0f", recurringNet), privacy: .public), projected=\(String(format: "%.0f", projectedBalance), privacy: .public) \(baseCurrency, privacy: .public)")

        let projectedMetricFormatted: String
        if recurringNet >= 0 {
            projectedMetricFormatted = "+" + Formatting.formatCurrencySmart(recurringNet, currency: baseCurrency)
        } else {
            projectedMetricFormatted = Formatting.formatCurrencySmart(recurringNet, currency: baseCurrency)
        }

        insights.append(Insight(
            id: "projected_balance",
            type: .projectedBalance,
            title: String(localized: "insights.projectedBalance"),
            subtitle: String(localized: "insights.in30Days"),
            metric: InsightMetric(
                value: recurringNet,
                formattedValue: projectedMetricFormatted,
                currency: baseCurrency,
                unit: String(localized: "insights.perMonth")
            ),
            trend: InsightTrend(
                direction: recurringNet >= 0 ? .up : .down,
                changePercent: currentBalance > 0 ? (recurringNet / currentBalance) * 100 : nil,
                changeAbsolute: recurringNet,
                comparisonPeriod: String(localized: "insights.currentBalance") + ": "
                    + Formatting.formatCurrencySmart(currentBalance, currency: baseCurrency)
            ),
            severity: projectedBalance >= 0 ? .positive : .critical,
            category: .cashFlow,
            detailData: nil
        ))

        Self.logger.debug("ðŸ’¸ [Insights] CashFlow END â€” \(insights.count) insights generated")
        return insights
    }

    // MARK: - Cash Flow from Period Points (Phase 18)

    @MainActor
    func generateCashFlowInsightsFromPeriodPoints(
        periodPoints: [PeriodDataPoint],
        allTransactions: [Transaction],
        granularity: InsightGranularity,
        baseCurrency: String,
        balanceFor: (String) -> Double
    ) -> [Insight] {
        guard periodPoints.count >= 2 else { return [] }

        var insights: [Insight] = []
        let currentKey = granularity.currentPeriodKey
        let latest = periodPoints.last(where: { $0.key == currentKey }) ?? periodPoints.last!
        let avgNetFlow = periodPoints.reduce(0.0) { $0 + $1.netFlow } / Double(periodPoints.count)

        // 1. Net cash flow trend
        let severity: InsightSeverity = latest.netFlow > 0 ? .positive : (latest.netFlow < 0 ? .critical : .neutral)
        insights.append(Insight(
            id: "net_cashflow",
            type: .netCashFlow,
            title: String(localized: "insights.netCashFlow"),
            subtitle: latest.label,
            metric: InsightMetric(
                value: latest.netFlow,
                formattedValue: Formatting.formatCurrencySmart(latest.netFlow, currency: baseCurrency),
                currency: baseCurrency,
                unit: nil
            ),
            trend: InsightTrend(
                direction: latest.netFlow > avgNetFlow ? .up : (latest.netFlow < avgNetFlow ? .down : .flat),
                changePercent: nil,
                changeAbsolute: latest.netFlow - avgNetFlow,
                comparisonPeriod: String(localized: "insights.vsAverage")
            ),
            severity: severity,
            category: .cashFlow,
            detailData: .periodTrend(periodPoints)
        ))

        // 2. Best period
        let bestPeriod = periodPoints.max(by: { $0.netFlow < $1.netFlow })
        if let best = bestPeriod {
            insights.append(Insight(
                id: "best_month",
                type: .bestMonth,
                title: granularity.bestPeriodTitle,
                subtitle: best.label,
                metric: InsightMetric(
                    value: best.netFlow,
                    formattedValue: Formatting.formatCurrencySmart(best.netFlow, currency: baseCurrency),
                    currency: baseCurrency,
                    unit: nil
                ),
                trend: nil,
                severity: .positive,
                category: .cashFlow,
                detailData: .periodTrend(periodPoints)
            ))
        }

        // 3. Worst period (Phase 24)
        if let worst = periodPoints.min(by: { $0.netFlow < $1.netFlow }),
           worst.netFlow < 0,
           worst.key != (bestPeriod?.key ?? "") {
            insights.append(Insight(
                id: "worst_month",
                type: .worstMonth,
                title: granularity.worstPeriodTitle,
                subtitle: worst.label,
                metric: InsightMetric(
                    value: worst.netFlow,
                    formattedValue: Formatting.formatCurrencySmart(worst.netFlow, currency: baseCurrency),
                    currency: baseCurrency,
                    unit: nil
                ),
                trend: nil,
                severity: .warning,
                category: .cashFlow,
                detailData: .periodTrend(periodPoints)
            ))
        }

        // 4. Projected balance â€” recurring delta scaled to granularity period.
        let currentBalance = transactionStore.accounts.reduce(0.0) { $0 + balanceFor($1.id) }
        let recurringNet = monthlyRecurringNet(baseCurrency: baseCurrency)

        let projectedPeriodMultiplier: Double
        let projectedPeriodUnit: String
        switch granularity {
        case .week:
            projectedPeriodMultiplier = 7.0 / 30.0
            projectedPeriodUnit       = String(localized: "insights.perWeek")
        case .quarter:
            projectedPeriodMultiplier = 3.0
            projectedPeriodUnit       = String(localized: "insights.perQuarter")
        case .year:
            projectedPeriodMultiplier = 12.0
            projectedPeriodUnit       = String(localized: "insights.perYear")
        case .month, .allTime:
            projectedPeriodMultiplier = 1.0
            projectedPeriodUnit       = String(localized: "insights.perMonth")
        }
        let periodRecurringNet  = recurringNet * projectedPeriodMultiplier
        let projectedBalance    = currentBalance + periodRecurringNet
        let projectedMetricFormatted = periodRecurringNet >= 0
            ? "+" + Formatting.formatCurrencySmart(periodRecurringNet, currency: baseCurrency)
            : Formatting.formatCurrencySmart(periodRecurringNet, currency: baseCurrency)

        insights.append(Insight(
            id: "projected_balance",
            type: .projectedBalance,
            title: String(localized: "insights.projectedBalance"),
            subtitle: projectedPeriodUnit,
            metric: InsightMetric(
                value: periodRecurringNet,
                formattedValue: projectedMetricFormatted,
                currency: baseCurrency,
                unit: projectedPeriodUnit
            ),
            trend: InsightTrend(
                direction: periodRecurringNet >= 0 ? .up : .down,
                changePercent: currentBalance > 0 ? (periodRecurringNet / currentBalance) * 100 : nil,
                changeAbsolute: periodRecurringNet,
                comparisonPeriod: String(localized: "insights.currentBalance") + ": "
                    + Formatting.formatCurrencySmart(currentBalance, currency: baseCurrency)
            ),
            severity: projectedBalance >= 0 ? .positive : .critical,
            category: .cashFlow,
            detailData: nil
        ))

        return insights
    }
}
